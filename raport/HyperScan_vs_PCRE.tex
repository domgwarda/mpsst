\documentclass[a4paper,11pt]{article}

\usepackage[T1]{fontenc}        % poprawne łamanie polskich znaków
\usepackage[utf8]{inputenc}     % kodowanie UTF-8
\usepackage[polish]{babel}      % język polski (nowocześniej niż \usepackage{polski})
\usepackage{microtype}

\usepackage{listings}

\setlength{\headheight}{16pt}
\usepackage{enumerate}

\usepackage{amssymb}		% pakiet do symboli
\usepackage{amsmath}		% pakiet do matmy

\usepackage{microtype}          % lepsze łamanie wierszy (bardzo polecane)
\usepackage[a4paper, margin=1.5cm, top=2cm, bottom=1.8cm]{geometry}

\usepackage{enumerate}
\usepackage{wrapfig} % enables wrapfigure environment
\usepackage{subcaption} % for subfigure environment
\usepackage{enumitem}		% punktowanie (a), (b), ...

\usepackage{graphicx}		% wstawianie obrazkow
\usepackage{float}			% wstawianie obrazkow w dowolnym miejscu
% \usepackage{tabstackengine} 	% macierze
\usepackage{fancyhdr}		% ładniejszy wygląd stronki
% \usepackage{color}   		% kolorowanie linków / odnośników
\usepackage{hyperref} %do linków
\hypersetup{
    colorlinks=true, 	% set true if you want colored links
    linktoc=all,     	% set to all if you want both sections and subsections linked
    linkcolor=black,  	% choose some color if you want links to stand out
}
\usepackage{titling}

\usepackage{tcolorbox}
\usepackage{listings}   % do ładnego kodu/regexów

\usepackage{newclude}
\usepackage{xinttools}
\usepackage{color}

\usepackage[a4paper, margin=1.5cm, top=2cm, bottom=1.8cm]{geometry}


% for + / -
\usepackage{tikz}
\newcommand{\Mypm}{\mathbin{\tikz [x=1.4ex,y=1.4ex,line width=.1ex] \draw (0.0,0) -- (1.0,0) (0.5,0.08) -- (0.5,0.92) (0.0,0.5) -- (1.0,0.5);}}%


\renewcommand\labelitemi{\raisebox{-0.3ex}{\huge\boldmath$\cdot$}} % obniżenie pkt + zmniejszenie
% przeciwko dzieleniu słów np bez- (enter) względny
\hyphenpenalty=10000
\exhyphenpenalty=10000

% \stackMath

% nowe komendy dla wygodniejszego pisania :)
\newcommand{\subtitle}[1]{ \posttitle{ \par\end{center} \begin{center}\large#1\end{center} \vskip0.5em}}
% \newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}

% Wyglad strony:
% \pagestyle{fancy}
\fancyhf{}
\chead{\leftmark}
\cfoot{\thepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \author{}
\title{\textbf{HyperScan vs PCRE}\\
Raport z projektu}
\author{Autorzy: \textbf{}}



% \subtitle{Redukcja}
\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\thispagestyle{empty}
\maketitle
\mbox{}

\section{Wydajności czasowe}

\subsection{Jak ilość regexów wpływa na czas wykonania się programu?}

\subsubsection{Podział wzorców regex}

W celu analizy wpływu charakteru wyrażeń regularnych na wydajność silników
Hyperscan i PCRE, zastosowane wzorce podzielono na cztery grupy różniące się
złożonością oraz właściwościami obliczeniowymi.

\begin{itemize}
    \item \textbf{Grupa 1 – literały (słowa)}  
    Pojedyncze ciągi znaków bez metaznaków regex.  
    Brak ograniczeń początku dopasowania, duża liczba potencjalnych trafień.

    \lstset{
      basicstyle=\ttfamily\small,
      backgroundcolor=\color{gray!5},
      frame=single,
      rulecolor=\color{gray!60}
    }
    \begin{lstlisting}
    Marketing
    Download
    upon
    needed
    \end{lstlisting}

    \item \textbf{Grupa 2 – regexy literalne z granicami słowa }  
    Długie literały ograniczone granicami słowa.  
    Mała liczba pozycji startowych i bardzo niska częstość dopasowań.

    \lstset{
      basicstyle=\ttfamily\small,
      backgroundcolor=\color{gray!5},
      frame=single,
      rulecolor=\color{gray!60}
    }
    \begin{lstlisting}
    (^|[^A-Za-z0-9_])uuro($|[^A-Za-z0-9_])
    (^|[^A-Za-z0-9_])ipxlydil($|[^A-Za-z0-9_])
    (^|[^A-Za-z0-9_])kbvu($|[^A-Za-z0-9_])
    (^|[^A-Za-z0-9_])dvgsgo($|[^A-Za-z0-9_])
    \end{lstlisting}


    \item \textbf{Grupa 3 – regexy strukturalne}  
    Wzorce o określonej strukturze (klasy znaków, kwantyfikatory, alternacje).  
    Szybkie odrzucanie niedopasowanych fragmentów tekstu.

    \lstset{
      basicstyle=\ttfamily\small,
      backgroundcolor=\color{gray!5},
      frame=single,
      rulecolor=\color{gray!60}
    }
    \begin{lstlisting}
    (sygjyojr|tqoeytlphoi)[ _-]?[0-9]{5}
    vwqujeqbus[._-]?sxcds
    (tzsv|oatwzycjn)[ _-]?[0-9]{3}
    uafffats[ \t\r\n\f\v]?(id|code|ref)[ \t\r\n\f\v]?[0-9]+
    \end{lstlisting}

    \item \textbf{Grupa 4 – regexy z szerokim dopasowaniem}  
    Wzorce zawierające wildcardy (\verb|.*|, \verb|.{0,200}|), alternacje i powtórzenia.  
    Duża przestrzeń dopasowania i potencjalnie wysoki koszt obliczeniowy.

    \lstset{
      basicstyle=\ttfamily\small,
      backgroundcolor=\color{gray!5},
      frame=single,
      rulecolor=\color{gray!60}
    }
    \begin{lstlisting}
    (?:zzblc|krnelhlomj|cbnrfmltbjnl)[^\n]{50,300}
    (?:flnrhy|nkyoscvqvs|ggbciouzrgqc).{0,200}(?:id|code|ref)[=:]?\d+
    (?:ohoceuukl\s*){2,6}ykhzzboa
    (?:[A-Za-z0-9_-]+/)+yljpnfnsdo
    \end{lstlisting}

    
\end{itemize}

Podział ten umożliwia porównanie zachowania silników dla wzorców o rosnącej
złożoności oraz analizę wpływu typu regexów na skalowanie czasowe.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsubsection{Wyniki}
\begin{figure}[h!]
\centering

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_regex_easy.png}
\end{subfigure}

\vspace{0.5em}

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_regex_normal.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_regex_hard.png}
\end{subfigure}


\end{figure}


\subsubsection{Wnioski}

\begin{itemize}
    \item Dla wszystkich typów regexów czas działania obu silników rośnie wraz z liczbą wzorców. Jednak wraz ze wzrostem liczby wzorców Hyperscan wyraźnie lepiej radzi sobie
    z szukaniem wzorców niż PCRE. Różnica pomiędzy silnikami rośnie wraz
    z liczbą regexów i dla dużych zbiorów staje się bazdzo znacząca.

    \item Najlepsze wyniki dla obu silników uzyskano w przypadku regexów
    strukturalnych oraz regexów z szerokim dopasowaniem, między którymi nie ma wyraźniej różnicy w zachowaniu żadnego z silników. W praktyce oznacza to, że obie te kategorie są przetwarzane w sposób bardziej stabilny, bez gwałtownych wzrostów czasu wraz z liczbą regexów.

    \item Hyperscan charakteryzuje się bardzo wysoką wydajnością we wszystkich
    analizowanych przypadkach - jego czas wykonania zmienia się tylko nieznacznie wraz ze wzrostem liczby i typu regexów.

    \item Silnik PCRE najlepiej radzi sobie z regexami strukturalnymi oraz z szerokim dopasowaniem, osiągając dla nich znacznie lepsze wyniki niż dla regexów prawie słownych, w których czas działania PCRE rośnie
    zauważalnie szybciej.
    
\end{itemize}
Uzyskane wyniki wskazują, że im większa jest liczba jednocześnie
    analizowanych wzorców, tym przewaga Hyperscana nad PCRE staje się
    wyraźniejsza, co czyni go szczególnie dobrze przystosowanym do zadań
    typu multi-pattern matching.

Dodatkowo "stały" czas HyperScana może wynikać z jużnie z pattern matchingu a poprostu otwierania, pobieraia itd plików

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage





\subsection{Jak ilość wątków wpływa na czas wykonania się programu?}

\subsubsection{Wyniki - 100 regexów}
\begin{figure}[h!]
\centering

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_words_100.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_easy_100.png}
\end{subfigure}

\vspace{0.5em}

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_normal_100.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_hard_100.png}
\end{subfigure}


\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsubsection{Wyniki - 1000 regexów}
\begin{figure}[h!]
\centering

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_words_1000.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_easy_1000.png}
\end{subfigure}

\vspace{0.5em}

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_normal_1000.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{bench_plot_threads_hard_1000.png}
\end{subfigure}


\end{figure}

\subsubsection{Wnioski}
\begin{itemize}
    \item Dla obu silników zwiększanie liczby wątków początkowo znacznie skraca czas wykoanania, co wskazuje na efektywne wykorzystanie równoległości.

    \item Dla PCRE liczba wątków, przy której osiągany jest najlepszy czas, zależy od typu regexów. Dla regexów słownych minimalny czas uzyskiwany jest przy większej liczbie wątków niż dla regexów strukturalnych i z szerokim dopasowaniem
    
    \item Dla regexów strukturalnych i z szerokim dopasowaniem przy dużej liczbie wątków (rzędu $\geq 100$) czasy działania Hyperscana i PCRE stają się do siebie zbliżone.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Jak ilość regexów vs ilość wątków wpływa na czas wykonania się programu?}

\subsubsection{literały (słowa)}
\begin{figure}[h!]
\centering

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{words_hs.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{words_pcre.png}
\end{subfigure}
\end{figure}

\subsubsection{regexy literalne z granicami słów}
\begin{figure}[h!]
\centering

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{easy_hs.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{easy_pcre.png}
\end{subfigure}
\end{figure}

\subsubsection{regexy strukturalne}
\begin{figure}[h!]
\centering

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{normal_hs.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{normal_pcre.png}
\end{subfigure}
\end{figure}


\subsubsection{regexy z szerokim dopasowaniem i alternacjami}
\begin{figure}[h!]
\centering

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{hard_hs.png}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{hard_pcre.png}
\end{subfigure}
\end{figure}

\subsubsection{Wnioski}
\begin{itemize}
    \item Dla HyperScana zwiększenie ilości wątków dla ma niewielki wpływ na czas działania

    \item Dla PCRE większa liczba wątków rzeczywiście przyspiesza działanie, jednak nie kompensuje w pełni wzrostu czasu wynikającego ze zwiększania liczby regexów.

    \item Dla PCRE to przy ilu wątkach osiąga najlepszy czas zależy od regexów, dla regexów typu słownych sporo dalej osiąga najniższy czas w przeciwieństwie do regexów strukturalnych czy z szerokim dopasowaniem gdzie osiąga najniższ czas dla podobnej ilości wątków co HyperScan 
    
    \item Podobnie jak w poprzedniej analizie, dla regexów strukturalnych i z szerokim dopasowaniem przy dużej liczbie wątków (rzędu $\geq 100$) czasy wykonywania obu silników stają się zbliżone.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Jak ilość małych ($\leq 3$\,MB) plików wpływa na czas wykonywania?}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{hs_300rgx_4000files.png}
\end{figure}

Pliki użyte w teście miały nie więcej niż $3$\,MB i zostały wygenerowane poleceniem:
\begin{quote}
\texttt{base64 /dev/urandom | head -c 3MB > ...}
\end{quote}
Do testów wykorzystano 100 wątków, a każdy program miał 3 podejścia do problemu. Wynikiem przedstawionym na wykresie jest średnia arytmetyczna całkowitego czasu wykonania.

\subsubsection{Przykłady regexów użytych w teście}

\lstset{
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{gray!5},
  frame=single,
  rulecolor=\color{gray!60}
}
\begin{lstlisting}
^[0-9]+(\.[0-9]+)?\s?(l|ml)$
^Saldo:\s-?[0-9]+,[0-9]{2}\sPLN$
^Dawka:\s[0-9]+(mg|ml)$
\end{lstlisting}

\subsubsection{Wnioski z wykresu}

\begin{itemize}[leftmargin=*, itemsep=2pt]
    \item Do około 100 plików, zarówno HS, jak i PCRE radziły sobie podobnie, z czasem wykonywania od 2 do 200\,milisekund.
    \item Wraz ze wzrostem liczby plików czas wykonywania PCRE rośnie znacznie szybciej niż HS.
    \item Przyspieszenie PCRE jest zdecydowanie większe niż przyspieszenie HS.
    \item Czas dzialania HS dla 4000 plikow nie przekracza 4s, a czas dzialania PCRE przewyzsza 120 sekund.
    \item HS lepiej radzi sobie z łączeniem skomplikowanych regexów przy pracy na wielu plikach.

\end{itemize}



\end{document}